#!/bin/octave## this function rig(p,q) finds the optimal rigid transform in 3-dimensional## euclidian space, using least squares and## single-value-decomposition. input a 3xn matrix (set of n 3d## positions), and the rotation matrtix r, it returns the translation## vector t.#### @ moritz siegelfunction [ affine_rotation, translation, s ] = affine( p, q )  assert( nargin == 2 && size( p ) == size( q ), ...          'need 2 identical input matrices' );  assert( size( p, 1 ) == 3, 'input matrix p must be 3xn' );  assert( size( q, 1 ) == 3, 'input matrix q must be 3xn' );  n = size( p, 2 );  assert( n > 2, 'need at least 3 points' );    ## 1) center    ## get rid of translation.  centroid_p = mean( p );  centroid_q = mean( q );  p_shifted = p - repmat( centroid_p, n, 1 );  q_shifted = q - repmat( centroid_q, n, 1 );  ## check centroids.  eps = 1e-8;  assert( mean( p_shifted ) < eps & mean( q_shifted ) < eps, "not centered" );  ## 2) orthogonal reduction  ## covariance matrices.  s_p = p_shifted' * p_shifted;  s_q = q_shifted' * q_shifted;#assert( [1,0,0] * s_p * [1,0,0]' > 0 & [1,0,0] * s_q * [1,0,0]' > 0, "not positive-definite"); # chol() checks that  ## inverse square-roots of the covariance matrices.  s_sqrt_p = chol( s_p, "lower" ); # choleski decomposition: A -> LL*  s_sqrt_q = chol( s_q, "lower" );  s_inv_sqrt_p = inv( s_sqrt_p ); # inverse: A -> A^-1  s_inv_sqrt_q = inv( s_sqrt_q );  p_orthogonal = ( s_inv_sqrt_p * p_shifted' )';  q_orthogonal = ( s_inv_sqrt_q * q_shifted' )';  ## p and q are now related by a rotational matrix r = s_inv_sqrt_q affine s_sqrt_p (no inverse!)  ## 3) recover rotation  ## covariance matrix  h = p_orthogonal' * q_orthogonal;  ## singular value decomposition  [ u, s, v ] = svd( h );  rotation = v * u';  if ( det( rotation ) < 0 )    printf( "warning: det(rotation) < 0" );    if ( any( s(:) ) < 0 )      printf( "found reflection, correcting." );      v(:,3) = -v(:,3);      rotation = v*u';    else      printf( "error: single-value-decomposition failed! \provided data seems is too noisy for least-squares." );      endif  endif  ## transform the rotation in the non-orthogonal affine transform.  affine_rotation = ( s_sqrt_q * rotation ) * s_inv_sqrt_p;  ## compute translation.  translation = centroid_q - ( affine_rotation * centroid_p' )';end